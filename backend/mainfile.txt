import os
from typing import List, Optional
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Query as FastAPIQuery
from pydantic import BaseModel
from pymongo import MongoClient
from sqlalchemy import create_engine, text as sql_text
from embedding_utils import flatten_candidate, get_embedding
from bson import ObjectId

load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), ".env"))

MONGO_URI = os.getenv("MONGO_URI")
MONGO_DB = os.getenv("MONGO_DB")
MONGO_CANDIDATES_COLLECTION = os.getenv("MONGO_CANDIDATES_COLLECTION", "candidates")
POSTGRES_URI = os.getenv("POSTGRES_URI")

mongo_client = MongoClient(MONGO_URI)
mongo_db = mongo_client[MONGO_DB]
candidates_col = mongo_db[MONGO_CANDIDATES_COLLECTION]
pg_engine = create_engine(POSTGRES_URI)

app = FastAPI()

# --- Pydantic Models for Full Schema ---
class PersonalInfo(BaseModel):
    full_name: str
    email: str
    phone: str
    linkedin: str
    github: str
    portfolio: str
    address: str
    summary: str

class Education(BaseModel):
    degree: str
    major: str
    university: str
    location: str
    start_date: str
    end_date: str
    gpa: str

class Experience(BaseModel):
    job_title: str
    company: str
    location: str
    start_date: str
    end_date: str
    responsibilities: List[str]
    technologies_used: List[str]

class Project(BaseModel):
    project_name: str
    description: str
    technologies: List[str]
    link: str

class Skills(BaseModel):
    technical: List[str]
    soft: List[str]
    languages: List[str]

class Certification(BaseModel):
    name: str
    issuing_organization: str
    issue_date: str
    expiration_date: Optional[str]
    credential_id: str
    credential_url: str

class Publication(BaseModel):
    title: str
    journal: str
    date: str
    url: str

class VolunteerExperience(BaseModel):
    role: str
    organization: str
    start_date: str
    end_date: str
    description: str

class AdditionalInfo(BaseModel):
    interests: List[str]
    volunteer_experience: List[VolunteerExperience]

class CandidateMongo(BaseModel):
    personal_info: PersonalInfo
    education: List[Education]
    experience: List[Experience]
    projects: List[Project]
    skills: Skills
    certifications: List[Certification]
    achievements: List[str]
    publications: List[Publication]
    additional_info: AdditionalInfo

class CandidateIn(BaseModel):
    candidate: CandidateMongo

@app.get("/")
def root():
    return {"message": "RAG Chatbot Backend is running"}

@app.post("/candidates")
def add_candidate(payload: CandidateIn):
    try:
        candidate_dict = payload.candidate.dict()
        result = candidates_col.insert_one(candidate_dict)
        mongo_id = str(result.inserted_id)
        flat = flatten_candidate(candidate_dict)
        emb = get_embedding(flat)
        with pg_engine.begin() as conn:
            conn.execute(sql_text("""
                INSERT INTO candidates (candidate_id, content, embedding)
                VALUES (:cid, :content, :embedding)
            """), {"cid": mongo_id, "content": flat, "embedding": emb})
        return {"id": mongo_id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to add candidate: {e}")

@app.get("/candidates/{candidate_id}")
def get_candidate(candidate_id: str):
    try:
        doc = None
        try:
            doc = candidates_col.find_one({"_id": ObjectId(candidate_id)})
        except Exception:
            pass
        if not doc:
            doc = candidates_col.find_one({"_id": candidate_id})
        if not doc:
            doc = candidates_col.find_one({"candidate_id": candidate_id})
        if not doc:
            raise HTTPException(status_code=404, detail="Candidate not found")
        doc["id"] = str(doc.get("_id", doc.get("candidate_id")))
        doc.pop("_id", None)
        return doc
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch candidate: {e}")

@app.get("/chatbot/query")
def chatbot_query(
    text: str = FastAPIQuery(None, alias="text"),
    query: str = FastAPIQuery(None, alias="query"),
    top_k: int = 5
):
    user_query = text or query
    if not user_query:
        raise HTTPException(status_code=422, detail="A query string is required.")
    try:
        query_emb = get_embedding(user_query)
        # Ensure query_emb is a list of floats
        emb_list = query_emb.tolist() if hasattr(query_emb, 'tolist') else list(query_emb)
        emb_str = "[" + ",".join(map(str, emb_list)) + "]"
        neon_query = f'''
            SELECT candidate_id, content
            FROM candidates
            ORDER BY embedding <-> '{emb_str}'::vector
            LIMIT {top_k}
        '''
        with pg_engine.connect() as conn:
            res = conn.execute(sql_text(neon_query))
            rows = res.fetchall()
        results = []
        doc_map = {}
        candidate_ids = [str(row[0]) for row in rows]
        try:
            object_ids = []
            for cid in candidate_ids:
                try:
                    object_ids.append(ObjectId(cid))
                except Exception:
                    pass
            if object_ids:
                for d in candidates_col.find({"_id": {"$in": object_ids}}):
                    key = str(d.get("_id"))
                    d["id"] = key
                    d.pop("_id", None)
                    doc_map[key] = d
        except Exception:
            pass
        for d in candidates_col.find({"_id": {"$in": candidate_ids}}):
            key = str(d.get("_id"))
            d["id"] = key
            d.pop("_id", None)
            doc_map[key] = d
        for d in candidates_col.find({"candidate_id": {"$in": candidate_ids}}):
            key = d.get("candidate_id")
            d["id"] = key
            d.pop("_id", None)
            doc_map[key] = d
        for row in rows:
            cid = str(row[0])
            doc = doc_map.get(cid)
            content = row[1]
            if not doc:
                results.append({
                    "id": cid,
                    "name": None,
                    "summary": content[:400],
                    "skills": [],
                    "experience": []
                })
                continue
            pi = doc.get("personal_info", {})
            exp = doc.get("experience", [])
            results.append({
                "id": doc["id"],
                "name": pi.get("full_name", ""),
                "summary": pi.get("summary", ""),
                "skills": doc.get("skills", {}).get("technical", []),
                "experience": [
                    {"job_title": e.get("job_title", ""), "company": e.get("company", "")} for e in exp
                ]
            })
        return {"results": results}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to run RAG pipeline: {e}")

import os
from fastapi import FastAPI, HTTPException, Query as FastAPIQuery
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from dotenv import load_dotenv
from pymongo import MongoClient
from sqlalchemy import create_engine, text
from sqlalchemy.exc import SQLAlchemyError
from embedding_utils import flatten_candidate, get_embedding
from bson import ObjectId
from typing import List

from models import CandidateIn, CandidateShort, ExperienceShort

load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), ".env"))

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- DB Connections ---
MONGO_URI = os.getenv("MONGO_URI")
MONGO_DB = os.getenv("MONGO_DB")
MONGO_CANDIDATES_COLLECTION = os.getenv("MONGO_CANDIDATES_COLLECTION", "candidates")
POSTGRES_URI = os.getenv("POSTGRES_URI")

mongo_client = MongoClient(MONGO_URI)
mongo_db = mongo_client[MONGO_DB]
candidates_col = mongo_db[MONGO_CANDIDATES_COLLECTION]
pg_engine = create_engine(POSTGRES_URI)

# --- Pydantic Models ---
class ExperienceShort(BaseModel):
    job_title: str
    company: str

class CandidateShort(BaseModel):
    id: str
    name: str
    summary: str
    skills: List[str]
    experience: List[ExperienceShort]


# --- MongoDB Candidate Schema (Pydantic) ---
class PersonalInfo(BaseModel):
    full_name: str
    email: str
    phone: str
    linkedin: str
    github: str
    portfolio: str
    address: str
    summary: str

class Education(BaseModel):
    degree: str
    major: str
    university: str
    location: str
    start_date: str
    end_date: str
    gpa: str

class Experience(BaseModel):
    job_title: str
    company: str
    location: str
    start_date: str
    end_date: str
    responsibilities: List[str]
    technologies_used: List[str]

class Project(BaseModel):
    project_name: str
    description: str
    technologies: List[str]
    link: str

class Skills(BaseModel):
    technical: List[str]
    soft: List[str]
    languages: List[str]

class Certification(BaseModel):
    name: str
    issuing_organization: str
    issue_date: str
    expiration_date: Optional[str]
    credential_id: str
    credential_url: str

class Publication(BaseModel):
    title: str
    journal: str
    date: str
    url: str

class VolunteerExperience(BaseModel):
    role: str
    organization: str
    start_date: str
    end_date: str
    description: str

class AdditionalInfo(BaseModel):
    interests: List[str]
    volunteer_experience: List[VolunteerExperience]

class CandidateMongo(BaseModel):
    personal_info: PersonalInfo
    education: List[Education]
    experience: List[Experience]
    projects: List[Project]
    skills: Skills
    certifications: List[Certification]
    achievements: List[str]
    publications: List[Publication]
    additional_info: AdditionalInfo

class CandidateIn(BaseModel):
    candidate: CandidateMongo

# --- API Endpoints ---
@app.get("/")
def root():
    return {"message": "RAG Chatbot Backend is running"}

@app.post("/candidates")
def add_candidate(payload: CandidateIn):
    try:
        # Insert into MongoDB
        candidate_dict = payload.candidate.dict()
        candidate_dict = payload.candidate.model_dump()
        result = candidates_col.insert_one(candidate_dict)
        mongo_id = str(result.inserted_id)
        # Flatten and embed

        flat = flatten_candidate(candidate_dict)
        emb = get_embedding(flat)
        # Insert into NeonDB

        with pg_engine.begin() as conn:
            conn.execute(text("""
                INSERT INTO candidates (candidate_id, content, embedding)
                VALUES (:cid, :content, :embedding)
            """), {"cid": mongo_id, "content": flat, "embedding": emb})
        return {"id": mongo_id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to add candidate: {e}")

from bson import ObjectId
@app.get("/candidates/{candidate_id}")
def get_candidate(candidate_id: str):
    try:
        doc = None
        # Try ObjectId
        try:
            doc = candidates_col.find_one({"_id": ObjectId(candidate_id)})
        except Exception:
            pass
        # Try as string _id

        if not doc:
            doc = candidates_col.find_one({"_id": candidate_id})
        # Try candidate_id field
        if not doc:
            doc = candidates_col.find_one({"candidate_id": candidate_id})

        if not doc:
            raise HTTPException(status_code=404, detail="Candidate not found")
        # Always return string id
        doc["id"] = str(doc.get("_id", doc.get("candidate_id")))
        doc.pop("_id", None)
        return doc
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch candidate: {e}")

@app.get("/chatbot/query")
def chatbot_query(text: str = FastAPIQuery(None, alias="text"),
    query: str = FastAPIQuery(None, alias="query"),
    top_k: int = 5):
                  query: str = FastAPIQuery(None, alias="query"),
                  top_k: int = 5):
    user_query = text or query
    if not user_query:
        raise HTTPException(status_code=422, detail="A query string is required.")

    try:
        # Step 1: Embed query
        query_emb = get_embedding(text)
        # Step 2: Vector search in NeonDB
        query_emb = get_embedding(user_query)

        with pg_engine.connect() as conn:
            res = conn.execute(sql_text("""
                SELECT candidate_id, content
                FROM candidates
                ORDER BY embedding <-> :query_emb
                LIMIT :top_k
            """), {"query_emb": query_emb, "top_k": top_k})
            """), {"query_emb": query_emb.tolist(), "top_k": top_k})
            rows = res.fetchall()
        # Step 3: Fetch from MongoDB and format

        candidate_ids = [str(row[0]) for row in rows]
        doc_map = _fetch_candidates_from_mongo(candidate_ids)

        results = []
        doc_map = {}
        # Pre-fetch all docs for candidate_ids in rows
        candidate_ids = [str(row[0]) for row in rows]
        # Try ObjectId fetch
        try:
            from bson import ObjectId
            object_ids = []
            for cid in candidate_ids:
                try:
                    object_ids.append(ObjectId(cid))
                except Exception:
                    pass
            if object_ids:
                for d in candidates_col.find({"_id": {"$in": object_ids}}):
                    key = str(d.get("_id"))
                    d["id"] = key
                    d.pop("_id", None)
                    doc_map[key] = d
        except Exception:
            pass
        # Try string _id fetch
        for d in candidates_col.find({"_id": {"$in": candidate_ids}}):
            key = str(d.get("_id"))
            d["id"] = key
            d.pop("_id", None)
            doc_map[key] = d
        # Try candidate_id field fetch
        for d in candidates_col.find({"candidate_id": {"$in": candidate_ids}}):
            key = d.get("candidate_id")
            d["id"] = key
            d.pop("_id", None)
            doc_map[key] = d
        # Build UI-friendly results preserving Neon ranking order
        for row in rows:
            cid = str(row[0])
            doc = doc_map.get(cid)
            content = row[1]

            if not doc:
                results.append({
                    "id": cid,
                    "name": None,
                    "summary": content[:400],
                    "skills": [],
                    "experience": []
                })
                results.append(CandidateShort(
                    id=cid,
                    name="Unknown Candidate",
                    summary=content[:400] + "..." if len(content) > 400 else content,
                    skills=[],
                    experience=[]
                ))
                continue

            pi = doc.get("personal_info", {})
            exp = doc.get("experience", [])
            results.append({
                "id": doc["id"],
                "name": pi.get("full_name", ""),
                "summary": pi.get("summary", ""),
                "skills": doc.get("skills", {}).get("technical", []),
                "experience": [
                    {"job_title": e.get("job_title", ""), "company": e.get("company", "")} for e in exp
                ]
            })
            results.append(CandidateShort(
                id=doc["id"],
                name=pi.get("full_name", "N/A"),
                summary=pi.get("summary", ""),
                skills=doc.get("skills", {}).get("technical", []),
                experience=[ExperienceShort(job_title=e.get("job_title", "N/A"), company=e.get("company", "N/A")) for e in exp]
            ))

        return {"results": results}
    except SQLAlchemyError as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to run RAG pipeline: {e}")

def _fetch_candidates_from_mongo(candidate_ids: List[str]) -> dict:
    doc_map = {}
    try:
        object_ids = [ObjectId(cid) for cid in candidate_ids if ObjectId.is_valid(cid)]
        if object_ids:
            for doc in candidates_col.find({"_id": {"$in": object_ids}}):
                doc["id"] = str(doc["_id"])
                doc.pop("_id", None)
                doc_map[doc["id"]] = doc
    except Exception:
        pass
    return doc_map
